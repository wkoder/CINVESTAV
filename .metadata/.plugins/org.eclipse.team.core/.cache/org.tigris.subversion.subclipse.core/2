#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "matrix.h"
#include "lu.h"

/*
 * main.c
 *
 *  Created on: Jul 17, 2011
 *      Author: Viridiana Ponce, Alexis de la Cruz, Moises Osorio
 */
extern int n, tam, a, b, a1, a2, b1, b2;
extern double *x;

void givensFactorization(double **A, double **R, int n) {
	int i, j, k;
	copyMatrix(n, n, A, R);
	for (j = 0; j < n; j++)
		for (i = n-1; i > j; i--) {
			double b, c, s;
			b = sqrt(R[i-1][j]*R[i-1][j] + R[i][j]*R[i][j]);
			c = R[i-1][j] / b;
			s = R[i][j] / b;
			for (k = j; k <= n; k++) {
				double x, y;
				x = c*R[i-1][k] + s*R[i][k];
				y = -s*R[i-1][k] + c*R[i][k];
				R[i][k] = y;
				R[i-1][k] = x;
			}
		}
}

void givens(double **A, int n) {
	double **D, **P, **R, **Q, **tmp;
	createMatrix(&D, n, n);
	createMatrix(&P, n, n);
	createMatrix(&Q, n, n);
	createMatrix(&R, n, n);
	createMatrix(&tmp, n, n);
	
	copyMatrix(n, n, A, D);
	unitMatrix(n, P);
	while (!isDiagonal(n, D)) {
		givensFactorization(D, R, n);
		inverseMatrix(n, D, tmp);
		multiplicationMatrix(n, n, R, tmp, Q);
		multiplicationMatrix(n, n, P, Q, tmp);
		copyMatrix(n, n, tmp, P);
		transposedMatrix(n, n, Q, tmp);
		multiplicationMatrix(n, n, R, tmp, D);
	}
}

int main(int argc, char **argv) {
	if (2 == 3) {
		int i, j;
		double **A, **R, **Q, **tmp, **tmp2;
		n = 5;
//		n = 3;
		
		createMatrix(&A, n, n);
		createMatrix(&R, n, n);
		createMatrix(&Q, n, n);
		createMatrix(&tmp, n, n);
		createMatrix(&tmp2, n, n);
//		givens(A, n);
		
		for (i = 0; i < n; i++)
			for (j = 0; j < n; j++)
//				A[i][j] = i+j + 1;
				A[i][j] = rand() / (double)RAND_MAX * 100;
//		A[0][0] = 6;
//		A[0][1] = 5;
//		A[0][2] = 0;
//		A[1][0] = 5;
//		A[1][1] = 1;
//		A[1][2] = 4;
//		A[2][0] = 0;
//		A[2][1] = 4;
//		A[2][2] = 3;
		
		givensFactorization(A, R, n);
		inverseMatrix(n, A, tmp);
		multiplicationMatrix(n, n, R, tmp, Q);
		
		multiplicationMatrix(n, n, Q, R, tmp);
		printf("A:\n");
		printMatrix(n, n, A);
		printf("Q*R:\n");
		printMatrix(n, n, tmp);
		printf("Q:\n");
		printMatrix(n, n, Q);
		printf("R:\n");
		printMatrix(n, n, R);
		transposedMatrix(n, n, Q, tmp);
		multiplicationMatrix(n, n, Q, tmp, tmp2);
		printf("Q*Q':\n");
		printMatrix(n, n, tmp2);
		
		return EXIT_SUCCESS;
	}
	
	int i;
	double **K, **M, **Q, **T, **aux, **InverseM;
	double **A, **Q2, **R;
	double **L, **U;
	double *eigenValues, **eigenVectors;

	int aux2;

	h = (double) (b - a) / n;
	alfa = (double) a2 / a1;
	beta = (double) b2 / b1;

	if (ua == 0 && ub == 0) {
		tam = n - 1;
		aux2 = 1;
	} else {
		tam = n + 1;
		aux2 = 0;
	}

	createVector(&x, tam);
	x[0] = a + (h * aux2);
	for (i = 1; i < tam; i++)
		x[i] = x[i - 1] + h;

	createMatrix(&K, tam, tam);
	createMatrix(&M, tam, tam);
	createMatrix(&InverseM, tam, tam);
	createMatrix(&Q, tam, tam);
	createMatrix(&T, tam, tam);
	createMatrix(&aux, tam, tam);

	createMatrix(&A, tam, tam);
	createMatrix(&Q2, tam, tam);
	createMatrix(&R, tam, tam);

	createMatrix(&L, tam, tam);
	createMatrix(&U, tam, tam);

	createVector(&eigenValues, tam);
	createMatrix(&eigenVectors, tam, tam);

	funcT = functionT;
	funcT2 = functionT2;

	funcQ = functionQ;
	funcM = functionM;

	triDiagonalMatrix(tam, funcT, funcT2, funcT, T);
	diagonalMatrix(tam, funcQ, Q);
	diagonalMatrix(tam, funcM, M);
	//inverseMatrix(tam, M, InverseM);

	escaleByMatrix(tam, tam, 1.0/pow(h, 2), T, aux);
	addMatrix(tam, tam, aux, Q, K);
	copyMatrix(tam,tam,K,A);
	factorizeUL(tam,A,eigenValues,eigenVectors);

	printf("Eigenvalues:\n");
	printVector(tam, eigenValues);
	printf("\nEigenvectors:\n");
	printMatrix(tam,tam, eigenVectors);

	destroyMatrix(&K, tam, tam);
	destroyMatrix(&M, tam, tam);
	destroyMatrix(&InverseM, tam, tam);
	destroyMatrix(&Q, tam, tam);
	destroyMatrix(&T, tam, tam);
	destroyMatrix(&aux, tam, tam);
	destroyMatrix(&A, tam, tam);
	destroyMatrix(&Q2, tam, tam);
	destroyMatrix(&R, tam, tam);
	destroyMatrix(&L, tam, tam);
	destroyMatrix(&U, tam, tam);
	destroyVector(&x, tam);

	destroyVector(&eigenValues, tam);
	destroyMatrix(&eigenVectors, tam, tam);

	return EXIT_SUCCESS;
}
