/*
 *  Created on: Nov 1, 2010
 *      Authors: Viridiana Ponce, Moises Osorio
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

//#define BY_BRUTE_FORCE
#define BY_LAYERS
//#define BY_CONSTRUCTION
#define MAX_N 10

void countSemigroupsByConstruction(int size, int a, int b, int c, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity);

int matrix[MAX_N][MAX_N];
int progress;

long long getTime() {
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return tv.tv_sec*1000000LL + tv.tv_usec;
}

void countSemigroupsByBruteForce(int size, int row, int col, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	if (row == size) { // Caso base, solo queda verificar
		int i, j, k;
		for (i = 0; i < size; i++)
			for (j = 0; j < size; j++)
				for (k = 0; k < size; k++)
					if (matrix[ matrix[i][j] ][ k ] != matrix[ i ][ matrix[j][k] ])
						return; // No es asociativo!

		(*count)++; // Es un semigrupo!

		int hasLeftIdentity = 0;
		for (i = 0; i < size; i++) { // Vemos si hay identidad izquierda
			hasLeftIdentity = 1;
			for (j = 0; j < size && hasLeftIdentity; j++)
				hasLeftIdentity &= matrix[i][j] == j;

			if (hasLeftIdentity) // Si la tiene asi que dejamos de buscar
				break;
		}

		int hasRightIdentity = 0;
		for (i = 0; i < size; i++) { // Vemos si hay identidad derecha
			hasRightIdentity = 1;
			for (j = 0; j < size && hasRightIdentity; j++)
				hasRightIdentity &= matrix[j][i] == j;

			if (hasRightIdentity) // Si la tiene, asi que dejamos de buscar
				break;
		}

		if (hasLeftIdentity)
			(*countWithLeftIdentity)++;
		if (hasRightIdentity)
			(*countWithRightIdentity)++;

		return;
	}

	if (col == size) {// Terminamos una fila, la que sigue!
		countSemigroupsByBruteForce(size, row + 1, 0, count, countWithLeftIdentity, countWithRightIdentity);
		return;
	}

	int i;
	for (i = 0; i < size; i++) {
		matrix[row][col] = i; // Prueba cada posibilidad
		countSemigroupsByBruteForce(size, row, col + 1, count, countWithLeftIdentity, countWithRightIdentity);
	}
}

void countSemigroupsByLayers(int size, int n, int row, int col, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	if (n == size) {
		(*count)++; // Es un semigrupo!

		int hasLeftIdentity = 0, i, j;
		for (i = 0; i < size; i++) { // Vemos si hay identidad izquierda
			hasLeftIdentity = 1;
			for (j = 0; j < size && hasLeftIdentity; j++)
				hasLeftIdentity &= matrix[i][j] == j;

			if (hasLeftIdentity) // Si la tiene, asi que dejamos de buscar
				break;
		}

		int hasRightIdentity = 0;
		for (i = 0; i < size; i++) { // Vemos si hay identidad derecha
			hasRightIdentity = 1;
			for (j = 0; j < size && hasRightIdentity; j++)
				hasRightIdentity &= matrix[j][i] == j;

			if (hasRightIdentity) // Si la tiene asi que dejamos de buscar
				break;
		}

		if (hasLeftIdentity)
			(*countWithLeftIdentity)++;
		if (hasRightIdentity)
			(*countWithRightIdentity)++;

		return;
	}

	int i, row2 = row, col2 = col;
	if (col2 == n)
		if (row2 >= 0)
			row2--; // Se mueve una celda hacia arriba
		else { // Agregamos una capa mas, hay que probar que sigue siendo asociativo
			int j;
			int k;
			for (i = 0; i <= n; i++)
				if (matrix[i][n] <= n && matrix[n][i] <= n)
					for (j = 0; j <= n; j++)
						if (matrix[i][j] <= n)
							for (k = 0; k <= n; k++)
								if (matrix[j][k] <= n)
									if (matrix[ matrix[i][j] ][ k ] != matrix[i][ matrix[j][k] ])
										return; // No es asociativo!

			countSemigroupsByLayers(size, n+1, n+1, 0, count, countWithLeftIdentity, countWithRightIdentity); // Llenamos la siguiente capa
			return;
		}
	else
		col2++; // Se mueve una celda hacia la derecha

	for (i = 0; i < size; i++) {
		matrix[row][col] = i;
		countSemigroupsByLayers(size, n, row2, col2, count, countWithLeftIdentity, countWithRightIdentity);
	}
}

void countSemigroupsByLayers2(int size, int n, int row, int col, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	if (n == size) {
		(*count)++; // Es un semigrupo!

		int hasLeftIdentity = 0, i, j;
		for (i = 0; i < size; i++) { // Vemos si hay identidad izquierda
			hasLeftIdentity = 1;
			for (j = 0; j < size && hasLeftIdentity; j++)
				hasLeftIdentity &= matrix[i][j] == j;

			if (hasLeftIdentity) // Si la tiene, asi que dejamos de buscar
				break;
		}

		int hasRightIdentity = 0;
		for (i = 0; i < size; i++) { // Vemos si hay identidad derecha
			hasRightIdentity = 1;
			for (j = 0; j < size && hasRightIdentity; j++)
				hasRightIdentity &= matrix[j][i] == j;

			if (hasRightIdentity) // Si la tiene asi que dejamos de buscar
				break;
		}

		if (hasLeftIdentity)
			(*countWithLeftIdentity)++;
		if (hasRightIdentity)
			(*countWithRightIdentity)++;

		return;
	}

	int row2 = row, col2 = col;

	int j, k, x, y, i;
	for (i = 0; i <= n; i++)
		for (j = 0; j <= n; j++)
			if ((x = matrix[i][j]) >= 0)
				for (k = 0; k <= n; k++)
					if ((y = matrix[j][k]) >= 0)
						if (matrix[x][k] != matrix[i][y] && matrix[x][k] >= 0 && matrix[i][y] >= 0)
							return; // No es asociativo!

	if (col2 == n)
		if (row2 >= 0)
			row2--; // Se mueve una celda hacia arriba
		else { // Agregamos una capa mas, hay que probar que sigue siendo asociativo
			countSemigroupsByLayers2(size, n+1, n+1, 0, count, countWithLeftIdentity, countWithRightIdentity); // Llenamos la siguiente capa
			return;
		}
	else
		col2++; // Se mueve una celda hacia la derecha

	//int x, y, k, ok;
	int ok;
	for (x = 0; x < size; x++) {
		matrix[row][col] = x;

		/**ok = 1;
		for (k = 0; k <= n; k++) {
			y = matrix[col][k];
			if (y >= 0 && matrix[x][k] >= 0 && matrix[row][y] >= 0 && matrix[x][k] != matrix[row][y]) {
				 ok = 0;
				 break;
			}
		}*/

		//if (ok)
			countSemigroupsByLayers2(size, n, row2, col2, count, countWithLeftIdentity, countWithRightIdentity);
	}

	matrix[row][col] = -1;
}

void countSemigroupsByConstructionAux(int size, int a, int b, int c, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	int x = matrix[a][b];
	int y = matrix[b][c];
	int w1 = matrix[x][c];
	int w2 = matrix[a][y];

	if (w1 >= 0 && w2 >= 0 && w1 != w2)
		return; // No es transitivo!

	int a2 = a, b2 = b, c2 = c+1; // Calculamos siguiente combinacion (a, b, c+1)
	if (c2 == size) { // (a, b+1, 0)
		c2 = 0;
		b2++;
	}
	if (b2 == size) { // (a+1, 0, 0)
		b2 = 0;
		a2++;
	}

	if (w1 == -1) {
		if (w2 == -1) {
			for (w1 = 0; w1 < size; w1++) {
				matrix[x][c] = matrix[a][y] = w1;
				countSemigroupsByConstruction(size, a2, b2, c2, count, countWithLeftIdentity, countWithRightIdentity);
			}

			matrix[x][c] = matrix[a][y] = -1;
		} else {
			matrix[x][c] = w2;
			countSemigroupsByConstruction(size, a2, b2, c2, count, countWithLeftIdentity, countWithRightIdentity);
			matrix[x][c] = -1;
		}
	} else if (w2 == -1) {
		matrix[a][y] = w1;
		countSemigroupsByConstruction(size, a2, b2, c2, count, countWithLeftIdentity, countWithRightIdentity);
		matrix[a][y] = -1;
	} else
		countSemigroupsByConstruction(size, a2, b2, c2, count, countWithLeftIdentity, countWithRightIdentity);
}

void countSemigroupsByConstruction(int size, int a, int b, int c, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	/**int current = a*size*size + b*size + c;
	if (current > progress) {
		progress = current;
		printf("%.2f %\n", progress*100.0/(size*size*size));
	}*/

	if (a == size) {
		(*count)++; // Es un semigrupo!

		int hasLeftIdentity = 0, i, j;
		for (i = 0; i < size; i++) { // Vemos si hay identidad izquierda
			hasLeftIdentity = 1;
			for (j = 0; j < size && hasLeftIdentity; j++)
				hasLeftIdentity &= matrix[i][j] == j;

			if (hasLeftIdentity) // Si la tiene, asi que dejamos de buscar
				break;
		}

		int hasRightIdentity = 0;
		for (i = 0; i < size; i++) { // Vemos si hay identidad derecha
			hasRightIdentity = 1;
			for (j = 0; j < size && hasRightIdentity; j++)
				hasRightIdentity &= matrix[j][i] == j;

			if (hasRightIdentity) // Si la tiene asi que dejamos de buscar
				break;
		}

		if (hasLeftIdentity)
			(*countWithLeftIdentity)++;
		if (hasRightIdentity)
			(*countWithRightIdentity)++;

		return;
	}

	int x = matrix[a][b];
	int y = matrix[b][c];
	if (x == -1) { // Probamos cada valor posible para X y/o Y = -1
		if (y == -1) {
			for (x = 0; x < size; x++)
				for (y = 0; y < size; y++) {
					matrix[a][b] = x;
					matrix[b][c] = y;
					countSemigroupsByConstructionAux(size, a, b, c, count, countWithLeftIdentity, countWithRightIdentity);
				}

			matrix[a][b] = matrix[b][c] = -1;
		} else {
			for (x = 0; x < size; x++) {
				matrix[a][b] = x; // Tratamos con el valor i
				countSemigroupsByConstructionAux(size, a, b, c, count, countWithLeftIdentity, countWithRightIdentity);
			}

			matrix[a][b] = -1; // Regresamos a su estado original
		}
	} else if (y == -1) {
		for (y = 0; y < size; y++) {
			matrix[b][c] = y; // Tratamos con el valor i
			countSemigroupsByConstructionAux(size, a, b, c, count, countWithLeftIdentity, countWithRightIdentity);
		}

		matrix[b][c] = -1; // Regresamos a su estado original
	} else
		countSemigroupsByConstructionAux(size, a, b, c, count, countWithLeftIdentity, countWithRightIdentity);
}

void countSemigroups(int size, long long *count, long long *countWithLeftIdentity, long long *countWithRightIdentity) {
	progress = 0;
	int i, j;
	for (i = 0; i < size; i++)
		for (j = 0; j < size; j++)
			matrix[i][j] = -1;

#ifdef BY_BRUTE_FORCE
	countSemigroupsByBruteForce(size, 0, 0, count, countWithLeftIdentity, countWithRightIdentity);
#else
#ifdef BY_LAYERS
	countSemigroupsByLayers2(size, 0, 0, 0, count, countWithLeftIdentity, countWithRightIdentity);
#else
	countSemigroupsByConstruction(size, 0, 0, 0, count, countWithLeftIdentity, countWithRightIdentity);
	(*count) /= size;
	(*countWithLeftIdentity) /= size;
	(*countWithRightIdentity) /= size;
#endif
#endif
}

int main() {
	printf("Conteo de Semigrupos:\n");
	int size;
	for (size = 1; size <= 6; size++) {
		long long count = 0;
		long long countWithLeftIdentity = 0;
		long long countWithRightIdentity = 0;

		long long time = getTime();
		countSemigroups(size, &count, &countWithLeftIdentity, &countWithRightIdentity);
		time = (getTime() - time) / 1000;

		printf("\nTamaÃ±o: %d\n", size);
		printf("Total: %lld\n", count);
		printf("Con identidad izquierda: %lld\n", countWithLeftIdentity);
		printf("Con identidad derecha: %lld\n", countWithRightIdentity);
		printf("Calculado en %lld ms\n", time);
	}
	return 0;
}
